"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllChangeLogEventV1FromTransaction = exports.deserializeApplicationDataEvent = exports.deserializeChangeLogEventV1 = void 0;
const bytes_1 = require("@project-serum/anchor/dist/cjs/utils/bytes");
const bn_js_1 = __importDefault(require("bn.js"));
const AccountCompressionEvent_1 = require("../generated/types/AccountCompressionEvent");
const constants_1 = require("../constants");
/**
 * Helper method for indexing a {@link ConcurrentMerkleTree}
 * @param data
 * @returns
 */
function deserializeChangeLogEventV1(data) {
    const event = AccountCompressionEvent_1.accountCompressionEventBeet
        .toFixedFromData(data, 0)
        .read(data, 0);
    if (event.__kind == "ChangeLog" && event.fields[0].__kind == "V1") {
        const changeLogV1 = event.fields[0].fields[0];
        return {
            treeId: changeLogV1.id,
            seq: new bn_js_1.default.BN(changeLogV1.seq),
            path: changeLogV1.path,
            index: changeLogV1.index,
        };
    }
    else {
        throw Error("Unable to decode buffer as ChangeLogEvent V1");
    }
}
exports.deserializeChangeLogEventV1 = deserializeChangeLogEventV1;
/**
 * Helper function for indexing data logged via `wrap_application_data_v1`
 * @param data
 * @returns
 */
function deserializeApplicationDataEvent(data) {
    const event = AccountCompressionEvent_1.accountCompressionEventBeet
        .toFixedFromData(data, 0)
        .read(data, 0);
    switch (event.__kind) {
        case "ApplicationData": {
            return event.fields[0];
        }
        default:
            throw Error("Unable to decode buffer as ApplicationDataEvent");
    }
}
exports.deserializeApplicationDataEvent = deserializeApplicationDataEvent;
/**
 * Helper function to extract the all ChangeLogEventV1 emitted in a transaction
 * @param txResponse - Transaction response from `@solana/web3.js`
 * @param noopProgramId - program id of the noop program used (default: `SPL_NOOP_PROGRAM_ID`)
 * @returns
 */
function getAllChangeLogEventV1FromTransaction(txResponse, noopProgramId = constants_1.SPL_NOOP_PROGRAM_ID) {
    var _a, _b;
    // ensure a transaction response was provided
    if (!txResponse)
        throw Error("No txResponse provided");
    // flatten the array of all account keys (e.g. static, readonly, writable)
    const accountKeys = txResponse.transaction.message
        .getAccountKeys()
        .keySegments()
        .flat();
    let changeLogEvents = [];
    // locate and parse noop instruction calls via cpi (aka inner instructions)
    (_b = (_a = txResponse.meta) === null || _a === void 0 ? void 0 : _a.innerInstructions) === null || _b === void 0 ? void 0 : _b.forEach((compiledIx) => {
        compiledIx.instructions.forEach((innerIx) => {
            // only attempt to parse noop instructions
            if (noopProgramId.toBase58() !==
                accountKeys[innerIx.programIdIndex].toBase58())
                return;
            try {
                // try to deserialize the cpi data as a changelog event
                changeLogEvents.push(deserializeChangeLogEventV1(Buffer.from(bytes_1.bs58.decode(innerIx.data))));
            }
            catch (__) {
                // this noop cpi is not a changelog event. do nothing with it.
            }
        });
    });
    return changeLogEvents;
}
exports.getAllChangeLogEventV1FromTransaction = getAllChangeLogEventV1FromTransaction;
//# sourceMappingURL=index.js.map